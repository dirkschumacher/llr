---
output:
  md_document:
    variant: markdown_github
---

[![Travis-CI Build Status](https://travis-ci.org/dirkschumacher/llr.svg?branch=master)](https://travis-ci.org/dirkschumacher/llr)
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/dirkschumacher/llr?branch=master&svg=true)](https://ci.appveyor.com/project/dirkschumacher/llr)
[![Coverage Status](https://img.shields.io/codecov/c/github/dirkschumacher/llr/master.svg)](https://codecov.io/github/dirkschumacher/llr?branch=master)

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
library(llr)
```

# llr

Lisp-like-R (llr). A work in progress, **just for fun** package to implement a lisp interpreter in R. The idea is to write a LISP that compiles to R's abstract syntax tree. It is implemented as an exercise for me to better understand LISP, but already works quite ok.


## Install

```{r, eval=FALSE}
devtools::install_github("dirkschumacher/llr")
```

## Features

### Datatypes

```{r, eval=FALSE}
llr("[1 2 3]") # list
llr("(quote (1 2 3))") # list
llr("1:10") # vector
llr("(seq 0 1 0.1)") # a single numeric vector (no list)
llr("pi") # single value
llr("0.3")
llr("3")
llr("3L")
```

### Special forms

```{r, eval = FALSE}
llr("(def x 1)") # bind a value to a symbol
llr("(defmacro hello [name] (paste0 \"Hello \" name))") # create a macro
```


### Functions

```{r, eval = FALSE}
llr("(fn [a] (> a 1))") # anonymous function
llr("(utils::head [1, 2, 3] 1)") # namspaced functions
llr("(Sys.Date)") # function without arguments
```
It does not yet support variadic functions, meaning functions with a variable number of arguments. Also at the moment you cannot yet define functions with `...` directly in R.

### Macros

LLR supports macros and expands these at compile time. Macros can be both written in R and LLR and work on R's data structures. You can use macros extend the language. In the example below we write a macro that rewrites `(a + b)` to `(+ a b)` at compile time, so you can write your binary additions in infix notation.

With `quote` you can quote code (i.e. prevent it from being evaluated) and with `UQ`, you can unquote it. Those two constructs can be used to modify data structures. Powered by [rlang](https://github.com/tidyverse/rlang).

```{r}
# a macro that evalues expressions in infix notations
# just for binary operations to make it simple
# also, seemles R <-> LLR interop
first <- function(x) x[[1L]]
rest <- function(x) tail(x, length(x) - 1L)
llr("
(defmacro infix [code]
  (quote
    ((UQ (first (rest code)))
     (UQ (first code))
     (UQ (first (rest (rest code)))))))    
")
llr("(infix (40 + 2))")
llr("((fn [x] (infix (2 + x))) 40)")
```


## Examples

```{r example}
llr("(Map (fn [x] (+ x 10)) (quote (1 2 3)))")
```

```{r}
llr("
  (def x [1 2 3 4 5])
  (Reduce (fn [acc x] (+ acc x)) 
    (Filter (fn [y] (> y 20)) (Map (fn [x] (* x 10)) x)))
")
```


```{r, message=FALSE}
llr("
 (library dplyr)
 (library tibble)
 (as_tibble (filter mtcars (> hp 180) (> cyl 6)))
")
```

```{r, message=FALSE}
llr("
  (library purrr)
  (def x 1:7)
  (as.numeric (keep x (fn [x] (> x 5))))
")
```

```{r}
llr("pi")
```

```{r}
llr("
  (def some_fun (fn [] (runif 1)))
  (some_fun)
")
```

```{r}
llr("(dplyr::filter mtcars (> hp 150))")
```

## REPL

It also has a repl :)

```{r, eval=FALSE}
llr::repl() # exit by typing (llr:exit)
```

[![asciicast](https://asciinema.org/a/129308.png)](https://asciinema.org/a/129308)

## Inspiration

* [Peter Norvig's article](http://norvig.com/lispy.html)
* [Make-a-lisp](https://github.com/kanaka/mal) - Great overview how to build a LISP. In particular I am currently using the regexp to tokenize the code.
* [Clojure](https://clojure.org/)
* [Hy](https://github.com/hylang/hy) - a lisp that compiles to pyhtons AST

## Tests

```{r}
covr::package_coverage()
```
